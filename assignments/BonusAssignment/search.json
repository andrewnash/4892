["Bonus Assignment A List of problems, with List.h Andrew Nash 201609492 03-Aug-2018 ","0 Executive Summary As would suggest by receiving 0% on an assignment, literally everything was wrong. This report details the complete over hall and re-design of the linked list assignment. The majority of fault in the original assignment submission was a result of poor implementation of the six different insertion methods. Due to these insertion methods not inserting properly, all other methods were unable to be tested (not that they would have worked well). After a short (but sweet) two month break from List.h much was learned from the following assignments which could be applied to this assignment. This resulted in three major design changes as follows: implementation of smart pointers, adding a previous reference to the node class (making it a doubly linked list) and combining all six insertion methods to rely on a single insert(). This resulted in a new assignment with much simpler, smarter, (and functional) code. ","1 Table of Contents Introduction ................................................................................................................................................................... 2 Node ................................................................................................................................................................................... 2 Pointers ............................................................................................................................................................................ 3 Insertion ........................................................................................................................................................................... 3 Constructors .................................................................................................................................................................. 5 Copy Constructor & Assignment Operator ................................................................................................ 5 Move Constructor & Assignment Operator ............................................................................................... 6 Erase ................................................................................................................................................................................... 6 Iterator .............................................................................................................................................................................. 7 Conclusions .................................................................................................................................................................... 7 ","2 Introduction The objective of this report is to detail the major design changes needed to fix assignment 1 (List.h) so it was able to pass the required test code. Node The first major design change to the Node Class was the addition of a ‘prev’ field which pointed to the previous node. This changed the List to be a double linked list instead of singly linked list. While this change would add some memory and complication to the Node Class it was deemed appropriate as it greatly simplified many other methods like insert() and erase(). The only design change made to the Node Class was removing the private declaration. As seen in Figure 0 and 1, the original Node had many methods used to access private fields which was unnecessary, instead the fields were updated to be public. Figure 0: Original Node class which included needless methods for accessing private fields. Figure 1: New Node Class containing the new prev_ variable and entirely public. ","3 Pointers The first major design change made to the List class was to switch all pointers (previously raw pointers) in the program to smart pointers. Since Node was also updated to have a pointer to the previous node, it made the most sense to use shared pointers to avoid multiple unique pointers, pointing at one object. The change in the List protected field can be seen in figure 2 and 3 below. Size The next major design change made was to add a size variable to the List classes private. Instead of scanning the list every time the size() method was called, instead, the size_ variable was just increased by 1 each time an element was added to the list. This dramatically simplified the size() method as seen in figure 4 versus figure 5 below. Figure 4: Original size() method before update. Insertion Another major design change made to the List class was relying on the insert() method to do all insertion to the list. Rather than having multiple similar versions of insert throughout the Class in push_front(), push_back() and more, it was much simpler to have mildly different calls of the insert() method. This can be seen in figure 6 and 7 on the following page. All the code in figure 6 was replaced by mildly different calls to the new Insert() method in figure 7. Figure 5: Updated and simplified size method. Figure 2: Original protected field containing raw pointers. Figure 3: Updated protected field with smart pointers. ","4 Figure 6: Original independent insertion methods. Figure 7: Update Insertion methods all relying upon Insert(). ","5 Constructors The original submission of List.h included a “last minute hack” in attempt to receive some partial marks (which didn’t work). As seen in figure 8, the original move constructor created the head and tail of the list and initialized them with the number 69, which was later over written with the correct head/ tail. Obviously, this is not ideal, either sentinel nodes should be used, or these nodes should start at Null Pointers. As well, this strategy would cause the list to fail for all type T’s that cannot hold 69 (like strings). The updated constructor relied upon the head’s and tail’s new default cases of Null Pointer so no constructor was need, hence it was left empty as seen in figure 9 below. Copy Constructor & Assignment Operator The original copy constructor just copied the head and tail of a list, this did not work at all. The original copy assignment however was on the correct track, the intent behind each operation of deleting the current list and replacing it with another list was correct but did not work in practice because of needless overcomplication in the program. The new copy constructor just called the copy assignment operator for simplicity and the new copy assignment operator fixed the minor errors in the old copy operator (and was updated for other design changes). This can be seen in figure 10 and 11. Figure 8: Original default constructor for List . Figure 9: New constructor, which is left empty on purpose. Figure 10: Original non-working copy constructor and copy assignment operator. Figure 11: New copy assignment operator. Copy constructor simply called this. ","6 Move Constructor & Assignment Operator Similar to the copy constructor and assignment operator, the respective move constructor and operator was updated. The original move operator was needlessly complicated and was reduced greatly by taking advantage of std::move(). See changes in figure 12 and 13 below. Erase Finally the erase method was updated to not only work in general, but also work with updated code. The addition of a pointer to the previous node made this method exponentially shorter and easier. This can be seen below in figure 14 and 15. Figure 12: Original Move assignment operator and constructor. Figure 13: New simplified Move assignment operator and constructor. Figure 14: Original erase() method. Figure 15: New erase() method taking advantage of having a pointer to the previous node. ","7 Iterator The iterator class needed no updates as it functionally worked, but unfortunately for the test code to evaluate the functionality of an iterator, a working linked list is required first. Conclusions Despite getting a 0% originally on this assignment many lesson were learned. Not only simple lessons like assuming programming assignments are easy and can be done last minute, but important concepts like smart pointers and memory management. Failing this assignment was a good wake up call that using debuggers is extremely useful and learning how to properly manage memory (and use pointers) is no longer something to skip over. "]